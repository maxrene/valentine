<!DOCTYPE html>

<html lang="en"><head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Romantic Verification | Prove Your Love</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>❤️</text></svg>">
<script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
<link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&amp;family=Playfair+Display:ital,wght@0,600;1,600&amp;display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&amp;display=swap" rel="stylesheet"/>
<script id="tailwind-config">
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "primary": "#ec1337",
                        "background-light": "#f8f6f6",
                        "background-dark": "#221013",
                    },
                    fontFamily: {
                        "display": ["Plus Jakarta Sans"]
                    },
                    borderRadius: {"DEFAULT": "1rem", "lg": "2rem", "xl": "3rem", "full": "9999px"},
                },
            },
        }
    </script>
<style>
        body {
            font-family: 'Plus Jakarta Sans', sans-serif;
        }
        .puzzle-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 8px;
        }
        /* Custom floating animation for hearts */
        @keyframes float {
            0% { transform: translateY(0px) rotate(0deg); opacity: 0.6; }
            50% { transform: translateY(-20px) rotate(10deg); opacity: 0.8; }
            100% { transform: translateY(0px) rotate(0deg); opacity: 0.6; }
        }

        @keyframes float-delayed {
            0% { transform: translateY(0px) rotate(0deg); opacity: 0.5; }
            50% { transform: translateY(-15px) rotate(-10deg); opacity: 0.7; }
            100% { transform: translateY(0px) rotate(0deg); opacity: 0.5; }
        }

        .floating-heart {
            animation: float 6s ease-in-out infinite;
        }

        .floating-heart-delayed {
            animation: float-delayed 7s ease-in-out infinite;
            animation-delay: 1s;
        }

        .bg-pattern {
            background-image: radial-gradient(#ec1337 1px, transparent 1px);
            background-size: 40px 40px;
        }
        .hint-target {
            outline: 3px dotted #ec1337 !important;
            outline-offset: -4px;
            z-index: 10;
        }
    </style>
</head>
<body class="bg-background-light dark:bg-background-dark min-h-screen flex flex-col relative overflow-y-auto overflow-x-hidden">
<!-- Background Pattern & Gradient -->
<div class="absolute inset-0 z-0 bg-primary/5 dark:bg-background-dark pointer-events-none"></div>
<div class="absolute inset-0 z-0 bg-pattern opacity-[0.07] pointer-events-none"></div>
<!-- Floating Background Hearts -->
<div class="absolute top-1/4 left-[10%] text-primary/20 floating-heart">
<span class="material-icons" style="font-size: 4rem;">favorite</span>
</div>
<div class="absolute bottom-1/4 right-[15%] text-primary/10 floating-heart-delayed">
<span class="material-icons" style="font-size: 6rem;">favorite</span>
</div>
<div class="absolute top-20 right-[20%] text-primary/15 floating-heart">
<span class="material-icons" style="font-size: 3rem;">favorite_border</span>
</div>
<div class="absolute bottom-20 left-[20%] text-primary/15 floating-heart-delayed">
<span class="material-icons" style="font-size: 3.5rem;">favorite_border</span>
</div>

<!-- Top Navigation Bar -->
<header class="w-full px-6 py-4 flex items-center justify-between border-b border-primary/10 bg-white/50 backdrop-blur-md">
<div class="flex items-center gap-2">
<div class="size-8 bg-primary rounded-full flex items-center justify-center text-white">
<span class="material-symbols-outlined text-lg">favorite</span>
</div>
<h1 class="text-[#1b0d10] text-lg font-bold leading-tight tracking-tight">Romantic Verification</h1>
</div>
<button id="refresh-btn" class="flex items-center justify-center rounded-full size-10 bg-primary/10 text-primary hover:bg-primary/20 transition-colors">
<span class="material-symbols-outlined">refresh</span>
</button>
</header>
<!-- Main Content Area -->
<main class="flex-1 flex items-center justify-center p-6">
<div class="max-w-[450px] w-full bg-white dark:bg-[#2d161a] p-8 rounded-xl shadow-[0_8px_30px_rgb(236,19,55,0.08)] border border-primary/5">
<!-- Card Header -->
<div class="text-center mb-8">
<h2 class="font-serif text-[#1b0d10] dark:text-white text-3xl font-semibold mb-2">Are you a robot?</h2>
<p class="text-primary/70 dark:text-primary/60 text-base font-medium">Prove your love (and humanity)</p>
<div class="flex items-center justify-center gap-2 mt-1">
    <p class="text-gray-500 dark:text-gray-400 text-sm">Slide the pieces to complete the heart.</p>
    <button id="hint-btn" class="text-gray-400 hover:text-primary transition-colors focus:outline-none" title="Show Hint">
        <span class="material-icons text-lg">lightbulb</span>
    </button>
</div>
</div>
<!-- Puzzle Section -->
<div class="bg-primary/5 p-4 rounded-lg border-2 border-dashed border-primary/20 mb-8">
    <div class="puzzle-grid aspect-square" id="puzzle-grid">
        <!-- Puzzle content will be generated by JS -->
    </div>
    <div class="hidden flex flex-col items-center justify-center p-6 mt-4 bg-primary/10 rounded-xl border border-primary/20 animate-in fade-in zoom-in duration-500" id="success-message">
        <span class="material-icons text-primary text-5xl mb-2">favorite</span>
        <p class="text-primary text-3xl font-bold tracking-tight">Valentine confirmée</p>
        <p class="text-primary text-xl font-medium mt-2">I love you ❤️</p>
        <p class="text-primary/70 text-sm mt-1">Verification Successful</p>
    </div>
</div>
<!-- Action Button -->

<!-- Footer Links -->
<div class="mt-6 flex flex-col items-center gap-3">


<p class="text-xs text-gray-400 dark:text-gray-500 flex items-center gap-1 mt-4">
<span class="material-symbols-outlined text-xs">lock</span>
                    Secure Romantic Verification
                </p>
</div>
</div>
</main>
<!-- Footer Decoration -->
<footer class="p-8 text-center text-gray-400 dark:text-gray-600 text-sm">
<p>© 2024 Romantic Captcha. Made with love for humanity.</p>
</footer>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const grid = document.getElementById('puzzle-grid');
        const successMsg = document.getElementById('success-message');
        const refreshBtn = document.getElementById('refresh-btn');
        const hintBtn = document.getElementById('hint-btn');
        const size = 3;
        let state = []; // will hold piece indices
        let isHintActive = false;
        let nextMove = null;
        const emptyPiece = 8;
        const imageUrl = 'couple1.JPG';

        // Configuration for image cropping
        const puzzleConfig = {
            cropX: 50, // 0-100% (0 = left, 50 = center, 100 = right)
            cropY: 50, // 0-100% (0 = top, 50 = center, 100 = bottom)
            aspectRatio: 6832 / 4555 // Aspect ratio of couple1.JPG
        };

        // Initialize state
        function init() {
            state = [0, 1, 2, 3, 4, 5, 6, 7, 8];
            isHintActive = false;
            nextMove = null;
            // Hide success message if visible
            successMsg.classList.add('hidden');

            // Shuffle by simulating moves to ensure solvability
            let moves = 0;
            let lastMove = -1;

            // Start solved, make 150 random valid moves
            for(let i=0; i<150; i++) {
                const emptyIdx = state.indexOf(emptyPiece);
                const neighbors = getNeighbors(emptyIdx);
                const validNeighbors = neighbors.filter(n => n !== lastMove);
                if (validNeighbors.length > 0) {
                    const randomNeighbor = validNeighbors[Math.floor(Math.random() * validNeighbors.length)];

                    // Swap
                    state[emptyIdx] = state[randomNeighbor];
                    state[randomNeighbor] = emptyPiece;
                    lastMove = emptyIdx;
                }
            }
            render();
        }

        function getNeighbors(idx) {
            const neighbors = [];
            const row = Math.floor(idx / size);
            const col = idx % size;

            if (row > 0) neighbors.push(idx - size); // up
            if (row < size - 1) neighbors.push(idx + size); // down
            if (col > 0) neighbors.push(idx - 1); // left
            if (col < size - 1) neighbors.push(idx + 1); // right

            return neighbors;
        }

        function getBgStyle(pieceIdx) {
            const row = Math.floor(pieceIdx / size);
            const col = pieceIdx % size;
            const ar = puzzleConfig.aspectRatio;
            let bgSize, bgPos;

            if (ar >= 1) {
                // Landscape: Fit Height (3 rows), Crop Width
                bgSize = 'auto 300%';
                // Y is standard (fits perfectly)
                const posY = row * 50;

                // X is dynamic based on crop
                // Formula derived for background-position percentage to map a tile to the correct part of the overflowing image
                const crop = puzzleConfig.cropX / 100;
                const denominator = (3 * ar) - 1;
                // Calculate position relative to the overflow
                const numerator = col + (3 * crop * (ar - 1));
                const posX = (numerator / denominator) * 100;

                bgPos = `${posX}% ${posY}%`;
            } else {
                // Portrait: Fit Width (3 cols), Crop Height
                bgSize = '300% auto';
                // X is standard (fits perfectly)
                const posX = col * 50;

                // Y is dynamic based on crop
                const crop = puzzleConfig.cropY / 100;
                const invAr = 1 / ar; // > 1
                const denominator = (3 * invAr) - 1;
                const numerator = row + (3 * crop * (invAr - 1));
                const posY = (numerator / denominator) * 100;

                bgPos = `${posX}% ${posY}%`;
            }
            return { bgSize, bgPos };
        }

        function render() {
            grid.innerHTML = '';
            state.forEach((pieceIdx, currentIdx) => {
                const div = document.createElement('div');
                div.className = 'rounded transition-all duration-200 shadow-sm relative overflow-hidden';

                if (pieceIdx === emptyPiece) {
                    div.className += ' bg-primary/5 flex items-center justify-center';
                     div.innerHTML = '<span class="material-icons text-primary/20 text-3xl">favorite_border</span>';
                } else {
                    div.className += ' bg-cover cursor-pointer hover:scale-[1.02] hover:shadow-md';
                    div.style.backgroundImage = `url('${imageUrl}')`;

                    const style = getBgStyle(pieceIdx);
                    div.style.backgroundSize = style.bgSize;
                    div.style.backgroundPosition = style.bgPos;

                    if (isHintActive && currentIdx === nextMove) {
                        div.classList.add('hint-target');
                    }

                    div.onclick = () => handleMove(currentIdx);
                }
                grid.appendChild(div);
            });
        }

        function handleMove(idx) {
            const emptyIdx = state.indexOf(emptyPiece);
            const neighbors = getNeighbors(emptyIdx);

            if (neighbors.includes(idx)) {
                // Swap
                state[emptyIdx] = state[idx];
                state[idx] = emptyPiece;

                // Disable hint after any move
                if (isHintActive) {
                    isHintActive = false;
                    nextMove = null;
                }

                render();
                checkWin();
            }
        }

        function updateHint() {
            if (isHintActive) {
                nextMove = solve(state);
                // If solved or no move found, stop hint
                if (nextMove === null) {
                    isHintActive = false;
                }
            } else {
                nextMove = null;
            }
        }

        function checkWin() {
            // Check if state is [0, 1, 2, 3, 4, 5, 6, 7, 8]
            const isWin = state.every((val, index) => val === index);
            if (isWin) {
                successMsg.classList.remove('hidden');
                // Disable interactions
                const pieces = grid.querySelectorAll('div');
                pieces.forEach(p => p.onclick = null);

                // Optional: Fill the missing piece to show full image
                const emptyDiv = grid.children[8];
                if (emptyDiv) {
                     emptyDiv.innerHTML = '';
                     emptyDiv.className = 'rounded transition-all duration-200 shadow-sm relative overflow-hidden bg-cover';
                     emptyDiv.style.backgroundImage = `url('${imageUrl}')`;

                     const style = getBgStyle(8); // Get style for the 9th piece (index 8)
                     emptyDiv.style.backgroundSize = style.bgSize;
                     emptyDiv.style.backgroundPosition = style.bgPos;
                }
            }
        }

        if (refreshBtn) {
            refreshBtn.addEventListener('click', init);
        }

        if (hintBtn) {
            hintBtn.addEventListener('click', () => {
                isHintActive = !isHintActive;
                updateHint();
                render();
            });
        }

        // --- Solver Logic ---
        function solve(currentState) {
            const target = [0, 1, 2, 3, 4, 5, 6, 7, 8];
            const startNode = {
                state: currentState.slice(),
                g: 0,
                h: calculateHeuristic(currentState),
                parent: null,
                move: null // The move (index) that led to this state
            };

            const openSet = [startNode];
            const closedSet = new Set();

            while (openSet.length > 0) {
                // Get node with lowest f = g + h
                // Simple sort for priority queue behavior
                openSet.sort((a, b) => (a.g + a.h) - (b.g + b.h));
                const currentNode = openSet.shift();

                const stateStr = currentNode.state.join(',');
                if (closedSet.has(stateStr)) continue;
                closedSet.add(stateStr);

                // Check if goal
                if (stateStr === target.join(',')) {
                    // Reconstruct path
                    let path = [];
                    let curr = currentNode;
                    while (curr.parent) {
                        path.unshift(curr.move);
                        curr = curr.parent;
                    }
                    return path.length > 0 ? path[0] : null; // Return the first move (index to click)
                }

                // Generate neighbors
                const emptyIdx = currentNode.state.indexOf(emptyPiece);
                const neighbors = getNeighbors(emptyIdx);

                for (const neighborIdx of neighbors) {
                    const newState = currentNode.state.slice();
                    // Swap
                    newState[emptyIdx] = newState[neighborIdx];
                    newState[neighborIdx] = emptyPiece;

                    const newNode = {
                        state: newState,
                        g: currentNode.g + 1,
                        h: calculateHeuristic(newState),
                        parent: currentNode,
                        move: neighborIdx // To reach newState, we clicked neighborIdx
                    };

                    openSet.push(newNode);
                }
            }
            return null;
        }

        function calculateHeuristic(state) {
            let distance = 0;
            for (let i = 0; i < state.length; i++) {
                const val = state[i];
                if (val === emptyPiece) continue; // Don't count empty piece

                const targetRow = Math.floor(val / size);
                const targetCol = val % size;
                const currentRow = Math.floor(i / size);
                const currentCol = i % size;

                distance += Math.abs(targetRow - currentRow) + Math.abs(targetCol - currentCol);
            }
            return distance;
        }

        init();
    });
</script>
</body></html>
